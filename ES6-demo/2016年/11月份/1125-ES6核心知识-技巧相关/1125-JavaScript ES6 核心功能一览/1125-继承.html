<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

继承
基于前面的 Animal 类。 让我们扩展它并定义一个 Lion 类。
在 ES5 中，它更多的与原型继承有关。

<script>
    // ES5
    var Lion = (function() {
        function MyConstructor(name) {
            Animal.call(this, name);
        }
        // 原型继承
        MyConstructor.prototype = Object.create(Animal.prototype);
        MyConstructor.prototype.constructor = Animal;
        MyConstructor.prototype.speak = function speak() {
            Animal.prototype.speak.call(this);
            console.log(this.name + ' roars 🦁');
        };
        return MyConstructor;
    })();
    var lion = new Lion('Simba');
    lion.speak(); // Simba makes a noise.
    // Simba roars.

</script>

我不会重复所有的细节，但请注意：

第 3 行中，我们添加参数显式调用了 Animal 构造函数。

第 7-8 行，我们将 Lion 原型指派给 Animal 原型。

第 11行中，我们调用了父类 Animal 的 speak 方法。

在 ES6 中，我们有了新关键词 extends 和 super superman shield。

<script>
    // ES6
    class Lion extends Animal {
        speak() {
            super.speak();
            console.log(this.name + ' roars 🦁');
        }
    }
    const lion = new Lion('Simba');

    lion.speak(); // Simba makes a noise.

    // Simba roars.
</script>

虽然 ES6 和 ES5 的代码作用一致，但是 ES6 的代码显得更易读。更胜一筹！

最佳实践：

使用 extends 内置方法实现继承。

<!-- -------------------------------------------------------------------------------- -->

</body>
</html>
