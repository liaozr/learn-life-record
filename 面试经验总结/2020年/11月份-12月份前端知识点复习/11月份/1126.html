<html>

3.Vuex有哪些重要概念

Vuex的核心概念：state、getter、mutation、action、module

state：状态，mapstate可以在页面里简化调用

Getter：相当于vue中的computed计算属性，getter的返回值会根据它的依赖被缓存起来，

且只有当它的依赖值发生了改变才会被重新计算，这里我们可以通过定义vuex的Getter来获取，

Getters 可以用于监听、state中的值的变化，返回计算后的结果，

muation：修改state中的值
action：调用mutation最大的好处是可以异步，分发请求
module：分割大型模块

------------------------------------------------------------------------------------------------


闭包是一个可以访问其他作用域的变量的函数

产生的原因

首先要了解作用域链的概念，函数的作用域就是它所创建的地方，也就是说，函数在它被创建的时候就已经确定好它的作用域了。


函数在执行的时候遇到一个变量，他会先看看自己的作用域里有没有该变量，没有的话就会向上从父级作用域里去查找，直到找到位置，否则报错undefined


function f1() {
     var a = 1;

    function f2() {
        console.log(a);
    }
    f2();
}
f1()//1


所以闭包的本质就是 存在对父级作用域的引用，这里注意，上面的代码并不是闭包，我们并没有通过调用f1()来访问到不属于它作用域的变量

，因为a本来就属于f1,我们只是通过f1调用了f2而已。


我们把上面的例子改造成闭包的形式，我们要在外面调用f2


function f1() {
    var a = 1;

    var f2 = function() {
        console.log(a);
    }
    return f2

}
const clousure = f1();
clousure();//1


我们把f2作为返回值，在外部进行调用，可以看到我们可以访问到f1的变量，这就是闭包，

也说明f2的作用域就是它所创建时的地方，而不是调用时的地方。


--------------------------------------------------------------------------------------------------


promise是es6对异步编程的一个方案，它有三种状态，

pending（挂起）,fullfilled(成功),rejected(拒绝)，状态一旦改变就不可逆。对应的变化有两种：

pending------> fullfilled  (resolved 解决)

pending------> rejected (rejected 拒绝)

通过then这个方法来实现异步调用之后的逻辑，另外还支持链式调用。

--------------------------------------------------------------------------------------------------

虚拟DOM相当于在js和真实dom中间加了一个缓存，利用dom diff算法避免了没有必要的doom操作，从而提高性能

具体实现步骤：
	·用JavaScript对象结构表示DOM树的结构；然后用这个树构建一个真正的DOM树，插到文档中

    ·当状态变更的时候，重新构造一棵树的对象树，然后用新的树和旧的树进行对比，记录两棵树差异

	·把2所记录的差异应用到步骤1所构建的真正的DOM树上，试图就更新了。

--------------------------------------------------------------------------------------------------


水平居中

行内元素：display: inline-block;

块级元素：margin: 0 auto;

Flex: display: flex; justify-content: center

垂直居中

行高 = 元素高：line-height: height

flex: display: flex; align-item: center

--------------------------------------------------------------------------------------------------


map: 遍历数组，返回回调返回值组成的新数组
forEach: 无法break，可以用try/catch中throw new Error来停止
filter: 过滤
some: 有一项返回true，则整体为true
every: 有一项返回false，则整体为false
join: 通过指定连接符生成字符串
push / pop: 末尾推入和弹出，改变原数组， 返回推入/弹出项【有误】
unshift / shift: 头部推入和弹出，改变原数组，返回操作项【有误】
sort(fn) / reverse: 排序与反转，改变原数组

--------------------------------------------------------------------------------------------------

组件中的data为什么是函数？

为什么组件中的data必须是一个函数，然后return一个对象，而new Vue实例里，data可以直接是一个对象？

// data
data() {
  return {
	message: "子组件",
	childName:this.name
  }
}

// new Vue
new Vue({
  el: '#app',
  router,
  template: '<App/>',
  components: {App}
})


因为组件是用来复用的，JS里对象是引用关系，这样作用域没有隔离，

而new Vue的实例，是不会被复用的，因此不存在引用对象问题




</html>