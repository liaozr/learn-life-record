<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  


说说vue2和vue3的diff算法的区别

在vue2中使用的是双端diff算法：是一种同时比较新旧两组节点的两个端点的算法（比头、比尾、头尾比、尾头比）。

一般情况下，先找出变更后的头部，再对剩下的进行双端diff。

在vue3中使用的是快速diff算法：它借鉴了文本diff算法的预处理思路，先处理新旧两组节点中相同的前置节点和后置节点。

当前置节点和后置节点全部处理完毕后，如果无法通过简单的挂载新节点或者卸载已经不存在的节点来更新，则需要根据节点间的索引关系，

构造出一个最长递增子序列。最长递增子序列所指向的节点即为不需要移动的节点。


-----------------------------------------------------------------------------------------------------------------------------------


关于vue3双向绑定的实现

vue3实现双向绑定的核心是Proxy（代理的使用），它会对需要响应式处理的对象进行一层代理，

对象的所有操作（get、set等）都会被Prxoy代理到。

在vue中，所有响应式对象相关的副作用函数会使用weakMap来存储。当执行对应的操作时，会去执行操作中所收集到的副作用函数。

-----------------------------------------------------------------------------------------------------------------------------------

computed和watch的区别

使用场景：computed适用于一个数据受多个数据影响使用；watch适合一个数据影响多个数据使用。

区别：computed属性默认会走缓存，只有依赖数据发生变化，才会重新计算，不支持异步，有异步导致数据发生变化时，无法做出相应改变

      watch不依赖缓存，一旦数据发生变化就直接触发响应操作，支持异步。


-----------------------------------------------------------------------------------------------------------------------------------

组件内的守卫

const Home = {
  template: `...`,
  beforeRouteEnter(to, from) {
      // 此时组件实例还未被创建，不能获取this
  },
  beforeRouteLeave(to, from) {
      // 导航离开渲染组件的对应路由时调用
  }
}

-----------------------------------------------------------------------------------------------------------------------------------

webpack常见的优化方案

基于esm的tree shaking

对balel设置缓存，缩小babel-loader的处理范围,及精准指定要处理的目录。

压缩资源（mini-css-extract-plugin，compression-webpack-plugin）

配置资源的按需引入（第三方组件库）

配置splitChunks来进行按需加载（根据）

设置CDN优化

-----------------------------------------------------------------------------------------------------------------------------------




</body>
</html>