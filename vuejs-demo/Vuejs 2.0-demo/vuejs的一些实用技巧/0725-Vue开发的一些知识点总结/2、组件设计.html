<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body>

大家都知道组件化的思想就是分治，几乎任意类型的应用程序界面，都可以抽象为一个组件树，

那我们该按照什么规则把应用抽象成组件，来应对复杂多变的业务需求呢。

我们从通信、黑箱，继承这几个角度来看看

通信： vue的父子组件通信机制是props down，events up，尽量保持松耦合，一直保持单向数据流的特点，并加以强约束。需要注意的时候，尽可能减少跨组件通信，例如使用$parent，$root。

继承： 当两个组件存在些许的共性，又存在足够的差异性的时候，就可以用到vue的继承---mixin，

他允许你封装一块在应用的其他组件中都可以使用的函数。如果使用姿势正确，
他们不会改变函数作用域外部的任何东西。而且mixin还有各种高阶用法，大家可自行查询（我也不会）。

黑箱： 组件的黑箱状态既只暴露易变的接口和方法，渲染给入的数据，组件内部封装不变的逻辑。

设计模式原则： 运用设计模式原则，比如单一职责原则，将组件拆分抽离成更细粒度，
保证高内聚性；再如接口隔离原则，采用稳定的服务端接口，将变化模块分离，

使得组件得以解耦；里氏替换原则、依赖倒置原则等等。。

<!-- ---------------------------------------------------------------------------------- -->


跨域

在浏览vue-cli的官方文档时候发现了vue-cli自带了API proxy，
解决了在项目中后端联调的时候的跨域问题。具体安装配置如下：

首先我们找到config文件下的index.js,再找到dev对象下的proxyTable属性，然后把以下代码添加进去

proxyTable: {
  '/api': {
    target: '网站名',
    pathRewrite: {
      '^/api': ''
    }
  }
}

然后重启本地服务器，这样你发送的/api/a就会代理发送到"网站名/a"了~

<!-- ---------------------------------------------------------------------------------- -->


  </body>
</html>
