<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

路由：页面跳转与模块关系

要说起路由，那可是有很长的故事。当我们在浏览器上输入网址的时候，我们就已经开始了各种路由的旅途了。

浏览器会检查有没有相应的域名缓存，没有的话就会一层层的去向 DNS服务器 寻向，最后返回对应的服务器的 IP 地址。
接着，我们请求的网站将会将由对应 IP 的 HTTP 服务器处理，HTTP 服务器会根据请求来交给对应的应用容器来处理。
随后，我们的应用将根据用户请求的路径，将请求交给相应的函数来处理。最后，返回相应的 HTML 和资源文化
当我们做后台应用的时候，我们只需要关心上述过程中的最后一步。

即，将对应的路由交给对应的函数来处理。这一点，在不同的后台框架的表现形式都是相似的。

如 Python 语言里的 Web 开发框架 Django 的 URLConf，使用正规表达式来表正

url(r'^articles/2003/$', views.special_case_2003),

而在 Laravel 里，则是通过参数的形式来呈现

<script>
    Route::get('posts/{post}/comments/{comment}', function($postId, $commentId) {
        //
    });
</script>

虽然表现形式有一些差别，但是总体来说也是差不多的。

而对于前端应用来说，也是如此，将对应的 URL 的逻辑交由对应的函数来处理。

React Router 使用了类似形式来处理路由，代码如下所示：

 <Route path="blog" component={BlogList} />
 <Route path="blog/:id" component={BlogDetail} />

当页面跳转到 blog 的时候，会将控制权将给 BlogList 组件来处理。

当页面跳转到 blog/fasfasf-asdfsafd 的时候，将匹配到这二个路由，并交给 BlogDetail 组件 来处理。

而路由中的 id 值，也将作为参数 BlogDetail 组件来处理。

相似的，而 Angular 2 的形式则是：

<script>
    {
        path: 'blog',
        component: BlogListComponent
    },
    {
        path: 'blog/:id',
        component: BlogDetailComponent
    }
</script>

相似的，这里的 BlogDetailComponent 是一个组件，path 中的 id 值将会传递给 BlogDetailComponent 组件。

从上面来看，尽管表现形式上有所差异，但是其行为是一致的：使用规则引擎来处理路由与函数的关系。

稍有不同的是，后台的路由完全交由服务器端来控制，

而前端的请求则都是在本地改变其状态。

并且同时在不同的前端框架上，他们在行为上还有一些区别。这取决于我们是否需要后台渲染，即刷新当前页面时的表现形式。

使用 Hash （#）或者 Hash Bang （#!） 的形式。即 # 开头的参数形式，诸如 ued.party/#/blog。当我们访问 blog/12 时，URL 的就会变成 ued.party/#/blog/12

使用新的 HTML 5 的 history API。用户看到的 URL 和正常的 URL 是一样的。当用户点击某个链接进入到新的页面时，会通过 history 的 pushState 来填入新的地址。当我们访问 blog/12 时，URL 的就会变成 ued.party/blog/12。当用户刷新页面的时候，请通过新的 URL 来向服务器请求内容。
幸运的是，大部分的最新 Router 组件都会判断是否支持 history API，再来决定先用哪一个方案。

<!-- -------------------------------------------------------------------------------- -->

一旦谈论到数据的时候，不可避免的我们就需要关心安全因素。

对于普通的 Web 应用来说，我们可以做两件事来保证数据的安全：

采用 HTTPS：在传输的过程中保证数据是加密的。
鉴权：确保指定的用户只能可以访问指定的数据。

目前，流行的前端鉴权方式是 Token 的形式，可以是普通的定制 Token，也可以是 JSON Web Token。

获取 Token 的形式，则是通过 Basic 认证——将用户输入的用户名和密码，经过 BASE64 加密发送给服务器。

服务器解密后验证是否是正常的用户名和密码，再返回一个带有时期期限的 Token 给前端。

随后，当用户去获取需要权限的数据时，需要在 Header 里鉴定这个 Token 是否有限，再返回相应的数据。

如果 Token 已经过期了，则返回 401 或者类似的标志，客户端就在这个时候清除 Token，并让用户重新登录。

<!-- -------------------------------------------------------------------------------- -->

数据展示：模板引擎

现在，我们已经获取到这些数据了，下一步所需要做的就是显示这些数据。

与其他内容相比，显示数据就是一件简单的事，无非就是：

依据条件来显示、隐藏某些数据

在模板中对数据进行遍历显示

在模板中执行方法来获取相应的值，可以是函数，也可以是过滤器。

依据不同的数值来动态获取样式等等

不同的框架会存在一些差异。并且现代的前端框架都可以支持单向或者双向的数据绑定。

当相应的数据发生变化时，它就可以自动地显示在 UI 上。

最后，在相应需要处理的 UI 上，绑上相应的事件来处理。

只是在数据显示的时候，又会涉及到另外一个问题，即组件化。

对于一些需要重用的元素，我们会将其抽取为一个通用的组件，以便于我们可以复用它们。

<my-sizer [(size)]="fontSizePx"></my-sizer>

并且在这些组件里，也会涉及到相应的参数变化即状态改变。

<!-- -------------------------------------------------------------------------------- -->

交互：事件与状态管理

完成一步步的渲染之后，我们还需要做的事情是：

交互。交互分为两部分：用户交互、组件间的交互——共享状态。

组件交互：状态管理

用户从 A 页面跳转到 B 页面的时候，为了解耦组件间的关系，我们不会使用组件的参数来传入值。而是将这些值存储在内存里，在适当的时候调出这些值。当我们处理用户是否登录的时候，我们需要一个 isLogined 的方法来获取用户的状态；

在用户登录的时候，我们还需要一个 setLogin 的方法；

用户登出的时候，我们还需要更新一下用户的登录状态。

在没有 Redux 之前，我都会写一个 service 来管理应用的状态。在这个模块里写上些 setter、getter 方法来存储状态的值，并根据业务功能写上一些来操作这个值。然而，使用 service 时，我们很难跟踪到状态的变化情况，还需要做一些额外的代码来特别处理。

有时候也会犯懒一下，直接写一个全局变量。这个时候维护起代码来就是一场噩梦，需要全局搜索相应的变量。如果是调用某个特定的 Service 就比较容易找到调用的地方。

----------------------------------------------------------------------------------

用户交互：事件

事实上，对于用户交互来说也只是改变状态的值，即对状态进行操作。

举一个例子，当用户点击登录的时候，发送数据到后台，由后台返回这个值。

由控制器一一的去修改这些状态，最后确认这个用户登录，并发一个用户已经登录的广播，又或者修改全局的用户值。

<!-- -------------------------------------------------------------------------------- -->


</body>
</html>
