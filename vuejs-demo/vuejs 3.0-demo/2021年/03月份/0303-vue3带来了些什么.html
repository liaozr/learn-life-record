<html>
  
Vue3会带来些什么？

更快

更小

更易于维护

新功能和特性

vue2中使用的是Options API; vue3中的是Composition API 简称纯函数式API

--------------------------------------------------------------------------------------------------------------------

更快:重构了Virtual DOM

标记静态内容，并区分动态内容

更新时只diff动态的部分


Vue3重写了虚拟DOM的实现方法，初始渲染/更新可以提速达100%。

对于Vue2.x版本的虚拟DOM来说，Vue会遍历 <template>模板中的所有内容，

并根据这些标签生成对应的虚拟DOM（虚拟DOM一般指采用key/value对象来保存标签元素的属性和内容），

当有内容改变时，遍历虚拟DOM来diff找到对应的标签元素所对应的DOM节点，并改变其内容。

当触发双向绑定时，遍历所有的 <div>标签和 <p>标签，找到 {{count}}变量对应的 <p>的DOM节点，并改变其内容。
    
这对于那些纯静态 <p>的节点进行diff其实是比较浪费资源的，当节点的数量很少时，表现并不明显，但是一旦节点的数量过大，

在性能上就会慢很多。

对此，Vue3在此基础上进行了优化主要有：

标记静态内容，并区分动态内容。

更新时只diff动态的部分。

针对上面的代码，Vue3中首先会区分出{{count}}这部分动态的节点，

在进行diff时，只针对这些节点进行，从而减少资源浪费，提升性能，具体这部分逻辑可以参考源码。

--------------------------------------------------------------------------------------------------------------------

事件缓存


我们知道在vue2中，针对节点绑定的事件，每次触发都要重新生成全新的function去更新。

在Vue3中，提供了事件缓存对象cacheHandlers，当cacheHandlers开启的时候，

编译会自动生成一个内联函数，将其变成一个静态节点，这样当事件再次触发时，就无需重新创建函数直接调用缓存的事件回调方法即可。

--------------------------------------------------------------------------------------------------------------------

基于Proxy的响应式对象



重构了 双向数据绑定

Object.defineProperty() --> Proxy API

Proxy 对于复杂的数据结构减少了循环递归的监听；初始渲染循环递归是非常耗性能的；

Proxy 对于数组的变异方法（会修改原数组），不在需要单独用数组原生方法重写、处理

语法也比defineProperty简洁多了，直接监听某个属性即可；



Proxy API对应的Proxy对象是ES2015就已引入的一个原生对象，用于定义基本操作的自定义行为（如属性查找、赋值、枚举、函数调用等）。

从字面意思来理解，Proxy对象是目标对象的一个代理器，任何对目标对象的操作（实例化，添加/删除/修改属性等等），

都必须通过该代理器。因此我们可以把来自外界的所有操作进行拦截和过滤或者修改等操作。例如下面的示例：

在Vue2.x中，使用Object.defineProperty()来实现响应式对象，

对于一些复杂的对象，还需要循环递归的给每个属性增加上getter/setter监听器，

这使得组件的初始化非常耗时，

而Vue3中，composition-api提供了一种创建响应式对象的方法reactive，

其内部就是利用了Proxy API来实现的，这样就可以不用针对每个属性来一一进行添加，减少开销提升性能

--------------------------------------------------------------------------------------------------------------------

代码目录结构遵循monorepo

monorepo是一种管理代码的方式，它的核心观点是所有的项目在一个代码仓库中，

但是代码分割到一个个小的模块中，而不是都放在src这个目录下面。

这样的分割，每个开发者大部分时只是工作在少数的几个文件夹以内的，并且也只会编译自己负责的模块，

而且不会导致一个 IDE 打不开太大的项目之类的事情，这样很多事情就简单了很多。

--------------------------------------------------------------------------------------------------------------------

更小 （Tree shaking支持）

简而言之： 不会把所有的都打包进来，只会打包你用到的api；大项目你会发现热加载、初始渲染提升了很多

很大程度的减少了开发中的冗余代码，提升编译速度

--------------------------------------------------------------------------------------------------------------------

更易于维护

Vue3从Flow迁移到TypeScript

多人协同开发的情况下，用了 TypeScript 之后的酸爽你会吐槽，为什么早不出现 TypeScript

--------------------------------------------------------------------------------------------------------------------

代码目录结构遵循monorepo

核心观点: 代码分割到一个个小的模块中, 开发者大部分只是工作在少数的几个文件夹，并且也只会编译自己负责的模块;而不是整个项目编译

--------------------------------------------------------------------------------------------------------------------

</html>