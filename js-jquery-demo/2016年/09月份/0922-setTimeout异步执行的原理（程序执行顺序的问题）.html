<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
<script>
    // 这个会输出什么
	for(var i = 0;i<10;i++){
	  setTimeout(function(){
	    console.log(i);  
	  },1000);
	}

//答案是输出10个10
//答案是输出10个10
//答案是输出10个10

// 因为setTimeout是异步的
// 首先，setTimeout是异步执行的。所以在setTimeout执行之前，全局变量i早就已经变成了10。

// 如果你想问的是这里为什么输出10？

// 因为异步函数必须等主进程运行完毕才会运行，setTimeout()内部回调运行的时候，主进程已经运行完毕了，此时i=10，所以输出10。

// 异步其实就是你去吃饭，但是厨师告诉你不能立即做好，需要等一段时间（主线程在跑其他代码）。
// 然后因为你很饿，所以你催了10次（注册了10次异步）。
// 等厨师有时间了，才回应你的要求并且给你做饭。
</script>

<!--------------------------------------------------------------------------------------------------------- -->

<script>

// setTimeout的延迟不是绝对精确的；
// setTimeout的意思是传递一个函数，延迟一段时候把该函数添加到队列当中，并不是立即执行；
// 所以说如果当前正在运行的代码没有运行完，即使延迟的时间已经过完，该函数会等待到函数队列中
// 前面所有的函数运行完毕之后才会运行；
// 也就是说所有传递给setTimeout的回调方法都会在整个环境下的所有代码运行完毕之后执行

    setTimeout(function(){
        console.log("here");
    }, 0);
    var i = 0;
    //具体数值根据你的计算机CPU来决定，达到延迟效果就好
    while (i < 9999) {
        i ++;
    }
    console.log("test");
// 运行以上代码，你会发现，上面的函数会等待while循环执行完毕之后才会运行，同时你还会发现，here输出在test的后面
</script>

<!-- --------------------------------------------------------------------------------------------------- -->

<script>
setTimeout(function(){
    console.log(1);
}, 2000);
console.log(2);
// 你看看 1 先输出还是 2 先输出，所谓异步，就是脱离你目前的执行流程。
</script>

<!-- ------------------------------------------------------------------------------------------------------- -->
</body>
</html>