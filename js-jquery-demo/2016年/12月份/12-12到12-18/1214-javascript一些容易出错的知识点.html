<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

1.你是否尝试过给numbers类型的数组排序❓

我们都知道， Javascript 提供了sort函数给我们使用， 那么我们来排一下


默认排序规则是数组元素 字符 的 Unicode 编码排序的，

也就是说数组元素会被当做字符串，然后按照字符串的 Unicode 编码进行升序排列。

那么如果我们想按照数字的大小排序，你应该这样做

<script>
    console.log(   [101, 2, 5, 100].sort( (a, b) => a - b )  )
    //[2, 5, 100, 101]
</script>

<!-- ------------------------------------------------------------------------------ -->

3. 为什么没有全部替换？

<script>
    let s = "bob"
    const replaced = s.replace('b', 'l')
    replaced === "lob" // first match only
    s === "bob" // original string is remained unchanged
</script>


我们都知道replace方法只会替换第一个，那么如果我要替换全部呢？

使用带有/ g的正则表达式：

<script>
     var ss = "bob"
     var new_ss=ss.replace(/b/g, 'l'); // replace all occurences

     console.log(new_ss); //lol
</script>

有空多看看正则表达式，它还有一个外号： 瑞士军刀

<!-- ------------------------------------------------------------------------------- -->

4. 相等不相等

<script>
    // These are ok
    'abc' === 'abc' // true
    1 === 1         // true

    // These are not 主要是看引用类型的比较所引起的不同。
    console.log( [1,2,3] === [1,2,3] ) // false
    var a=[1,2,3]
    var b=[1,2,3]
    var c=a;
    console.log(a===b)  //false

    console.log(a===c)  //true

    console.log( {a: 1} === {a: 1} )  // false
    console.log( {} === {}   )        // false
</script>

原因：[1,2,3]和[1,2,3]是两个单独的数组。 它们恰好包含相同的值。 它们是不同的引用;

数组是地址引用的，地址不一样，就是不相等。

这里我相信大部分人都是理解的；

主要是基本类型的比较和引用类型的比较的不同；
主要是基本类型的比较和引用类型的比较的不同；

我们再看多看一个东西： ==

<script>
    [10] ==  10      // 为 true
    [10] === 10      // 为 false

    '10' ==  10      // 为 true
    '10' === 10      // 为 false

     []  ==  0       // 为 true
     []  === 0       // 为 false

     ''  ==  false   // 为 true 但 true == "a" 为false
     ''  === false   // 为 false
 </script>

== (或者 !=) 操作在需要的情况下自动进行了类型转换（隐式强制转换）。=== (或 !==)操作不会执行任何转换

隐式强制转换的规则（来源justjavac）：

当 JavaScript 需要一个布尔值时（例如：if 语句),隐式转换为布尔：“truthy”和“falsy”
下面的值被转换为 false：

undefined, null
Boolean: false
Number: -0, +0, NaN
String: ‘’

对象的隐式转换
只有在 JavaScript 表达式或语句中需要用到数字或字符串时，对象才被隐式转换。 当需要将对象转换成数字时，需要以下三个步骤：
调用 valueOf()。如果结果是原始值（不是一个对象），则将其转换为一个数字。
调用 toString() 方法。如果结果是原始值，则将其转换为一个数字。
否则，抛出一个类型错误。
字符串的隐式转换
加运算符+ 因为只要其中一个操作数是字符串，那么它就执行连接字符串的操作（而不是加法操作，即使它们是数字）

<!-- ---------------------------------------------------------------------------------- -->

5.Array 的类型？

<script>
    typeof {} === 'object' // true
    typeof 'a' === 'string' // true
    typeof 1 === number // true
        // But....
    typeof [] === 'object' // true
</script>

原作者提供了使用

Array.isArray()方法用来检测数组类型

这里多提供几种

<script>
    const arr = ['l', 'o', 'v', 'e']

    // instanceof
    console.log(arr instanceof Array) //true
</script>

<!-- -------------------------------------------------------------------------------- -->


</body>
</html>
