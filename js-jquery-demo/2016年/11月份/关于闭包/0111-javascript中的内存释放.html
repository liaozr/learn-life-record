<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

<script>
    var num = 20;

    function fn() {
        var num = 200;
        return function() {
            console.log(num);
        };
    }
    var f = fn();
    f(); // 输出 200


// ----------------------------------------------------------------------------
    ~ function() {
        var num = 2000;
        f(); // 输出什么呢？
    }();

    //  输出的结果是 200 200 -1   （之所以-1 是因为 波浪线~ 按位取反，函数没有返回值的情况下）
    //  函数没有返回值的情况下，~按位取反，永远都是  值为-1的

    //  第二个 f() 之所以还是输出200。因为是第二次执行f()，所以他 作用域 里面的变量都已经被缓存了。
    // 所以num值还是不变的 ，为 200 。详情可以继续往下看。
</script>

加上了一个自执行函数，我们知道自执行函数是有自己的作用域的，但是此时f函数执行，依然输出200。

要时刻上级作用域的查找规则：只看当前函数在哪个作用域下定义的。

<!-- ------------------------------------------------------------------------------ -->

函数返回来一个引用数据类型的值（数组、函数...），

并且该引用类型的值在函数的外面被一个其他变量接收了，

这种情况下形成的私有作用域都不会销毁。

注意两个条件：
（1）函数返回引用数据类型的值；
（2）该引用类型的值在函数外面被一个其他变量接收了；

<!-- -------------------------------------------------------------------------------- -->

<script>
    function fn() {
        var num = 100;
        return function() {
            num++;
            console.log(num);
        }
    }
    var f = fn(); // fn执行形成的作用域就不能再销毁了
</script>

注意：即使fn返回的函数中什么代码都没有，没有使用到fn私有作用域中的任何变量和函数，在以上情况下，fn的私有作用域也不会被销毁，即：
<script>
    function fn() {
        var num = 100;
        return function() {}
    }
    var f = fn();
</script>

<!-- --------------------------------------------------------------------------------- -->

在一个私有作用域中，给DOM元素绑定方法，私有作用域不能被销毁

<script>
    var btn = document.getElementById('btn1');
    ~ function() {
        btn.onclick = function() {}
    }();
</script>

在自执行函数中形成了一个私有的作用域，在这个私有作用域中为页面上的一个button元素绑定了点击事件，

所以这个私有作用域也不能被销毁。

<!-- ------------------------------------------------------------------------------ -->

“不立即销毁”

<script>

    function fn() {
        var num = 100;
        return function() {}
    }

    fn()(); // 首先执行fn，返回一个小函数对应的内存地址，然后紧接着让返回的小函数再执行
</script>

以上代码就是“不立即销毁”的情况，fn返回的函数没有被其他的任何变量占用，但是还需要执行一次，所以暂时不能销毁，但返回的值执行完成后，浏览器会在空闲的时候把它销毁了。

只要某作用域还有被引用，那么该作用域就不能被销毁，一旦没有任何变量引用了，

该私有作用域就会被销毁了。

<!-- ------------------------------------------------------------------------------- -->

i++是 执行完后面的语句才加1；而 ++i就先做 i+1才执行后面的语句。

i++返回的是自增之前的值，++i返回的则是自增后的值。

 <script>
    var i = 1;
    var a = i++;
    var b = ++i;

    console.log(a)    //a = 1;  此时i为2，但赋给a的值是1
    console.log(b)   //b = 3
</script>

<!-- ------------------------------------------------------------------------------- -->

<script>

    function fn0() {
        var i = 10;
        return function(n) {
            console.log(n + (++i));
        };
    }
    var f = fn0();

    f(10)  ;        //  21
    f(20)   ;      // 32
    fn0()(10) ;   // 21
    fn0()(20) ;  // 31
</script>

<!-- ------------------------------------------------------------------------------- -->

<script>
    function fn1(i) {
        return function(n) {
            // i++是 执行完后面的语句才加1；而 ++i就先做 i+1才执行后面的语句。
            console.log(n + i++);
        }
    }
    var f = fn1(13);

     f(12)      //->25
     f(14)        //->28
     fn1(15)(12)        //->27
     fn1(16)(13)        //->29
</script>

<!-- --------------------------------------------------------------------------------- -->

<script>
    function fn1(i) {
        return function(n) {
            // i++是 执行完后面的语句才加1；而 ++i就先做 i+1才执行后面的语句。
            console.log(n + ++i);
        }
    }
    var f = fn1(13);

   f(12)       //->26
   f(14)         //->29
   fn1(15)(12)         //->28
   fn1(16)(13)         //->30

</script>

<!-- -------------------------------------------------------------------------------- -->


</body>
</html>
