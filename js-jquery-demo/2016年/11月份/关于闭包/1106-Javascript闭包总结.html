<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>

说了半天，究竟什么是闭包呢？

闭包就是函数的局部变量集合，只是这些局部变量在函数返回后会继续存在。

闭包就是就是函数的“堆栈”在函数返回后并不释放，我们也可以理解为这些函数堆栈并不在栈上分配而是在堆上分配。

当在一个函数内定义另外一个函数就会产生闭包。

<!-- ------------------------------------------------------------------- -->

为了便于理解，我们可以简单的将闭包理解为：

闭包：是指有权访问另外一个函数作用域中的变量的函数。

<!-- ------------------------------------------------------------ -->

JavaScript中的作用域

另一方面，在函数外部自然无法读取函数内的局部变量。
<script>
	function f1(){
	　　　　var n=999;
	}
	alert(n); // error
</script>

这里有一个地方需要注意，函数内部声明变量的时候，一定要使用var命令。

如果不用的话，你实际上声明了一个全局变量。
<script>
	function f1(){
	　　　　n=999;
	}
	f1();
	alert(n); // 999
</script>

<!-- -------------------------------------------------------------------- -->

1.理解闭包

我们已经理解了什么是作用域，什么是块级作用域，那又该如何去访问函数内部的变量呢？
出于种种原因，我们有时候需要得到函数内的局部变量。但是，前面已经说过了，正常情况下，这是办不到的，只有通过变通方法才能实现。
<script>
	　function f1(){
	　　　　var n=999;
	　　　　function f2(){
	　　　　　　alert(n);
	　　　　}
	        return f2;
	　}
	　var result=f1();
	　result();// 弹出999
</script>

上面函数中的f2函数就是闭包，就是通过建立函数来访问函数内部的局部变量。

<!-- ---------------------------------------------------------------------- -->

2.闭包的用途

  闭包可以用在许多地方。它的最大用处有两个，一个是前面提到的可以读取函数内部的变量，

  另一个就是让这些变量的值始终保持在内存中。
<script>
　　function f1(){
　　　　var n=999;
　　　　nAdd=function(){n+=1}
　　　　function f2(){
　　　　　　alert(n);
　　　　}
　　　　return f2;
　　}
　　var result=f1();
　　result(); // 999
　　nAdd();
　　result(); // 1000
</script>

在这段代码中，result实际上就是闭包f2函数。它一共运行了两次，第一次的值是999，第二次的值是1000。

这证明了，函数f1中的局部变量n一直保存在内存中，并没有在f1调用后被自动清除。

为什么会这样呢？原因就在于f1是f2的父函数，而f2被赋给了一个全局变量，这导致f2始终在内存中，而f2的存在依赖于f1，因此f1也始终在内存中，不会在调用结束后，被垃圾回收机制（garbage collection）回收。

这段代码中另一个值得注意的地方，就是”nAdd=function(){n+=1}”这一行，首先在nAdd前面没有使用var关键字，因此nAdd是一个全局变量，
而不是局部变量。

其次，nAdd的值是一个匿名函数（anonymous function），而这个匿名函数本身也是一个闭包，所以nAdd相当于是一个setter，可以在函数外部对函数内部的局部变量进行操作。

<!-- --------------------------------------------------------------------------- -->

3.闭包的注意点

1）由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，

所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。

2）闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。

<!-- --------------------------------------------------------------------------- -->

4.经典闭包小案例

如果你能理解下面全部的案例，那你的闭包就算是真正掌握了。

<!-- ---------------------------------------------------------------- -->

<script>

　　var name = "The Window";

　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　return function(){
　　　　　　　　return this.name;
　　　　　　};
　　　　}
　　};
　　alert(object.getNameFunc()());//The Window

// 谁调用，this就指向谁
// 下面那个是全局调用，所以指向了window
// 也算是闭包，但重点不是闭包，是this指向
</script>

<!-- -------------------------------------------------------------- -->

<script>

　  var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　var that = this;
　　　　　　return function(){
　　　　　　　　return that.name;
　　　　　　};
　　　　}
　　};
　　alert(object.getNameFunc()());//My Object

// 缓存了个this
// 就是改变了指向
// 所以调用的时候，this指向缓存值
</script>

<!-- ------------------------------------------------------------------------------ -->

<script>

	function fun(n,o) {
	  console.log(o)
	  return {
	    fun:function(m){
	      return fun(m,n);
	    }
	  };
	}
	var a = fun(0);

    a.fun(1);  a.fun(2);  a.fun(3);//undefined,?,?,?

	var b = fun(0).fun(1).fun(2).fun(3);//undefined,?,?,?

	var c = fun(0).fun(1);  c.fun(2);  c.fun(3);//undefined,?,?,?

	//问:三行a,b,c的输出分别是什么？

	// 这是一道非常典型的JS闭包问-题。其中嵌套了三层fun函数，搞清楚每层fun的函数是那个fun函数尤为重要。

	//答案：
	//a: undefined,0,0,0
	//b: undefined,0,1,2
	//c: undefined,0,1,1
</script>

先看第一个fun函数，属于标准具名函数声明，是新创建的函数，他的返回值是一个对象字面量表达式，属于一个新的object。

这个新的对象内部包含一个也叫fun的属性，通过上述介绍可得知，属于匿名函数表达式，即fun这个属性中存放的是一个新创建匿名函数表达式。

注意：所有声明的匿名函数都是一个新函数。

所以第一个fun函数与第二个fun函数不相同，均为新创建的函数。

----------------------------------------------------------------------------------

结论是：使用var或是非对象内部的函数表达式内，可以访问到存放当前函数的变量；在对象内部的不能访问到。

原因也非常简单，因为函数作用域链的问题，采用var的是在外部创建了一个fn变量，函数内部当然可以在内部寻找不到fn后向上册作用域查找fn，而在创建对象内部时，因为没有在函数作用域内创建fn，所以无法访问。

所以综上所述，可以得知，最内层的return出去的fun函数不是第二层fun函数，是最外层的fun函数。

所以，三个fun函数的关系也理清楚了，第一个等于第三个，他们都不等于第二个。

----------------------------------------------------------------------------------

两个fun函数(第一个和第三个相同)，遂接下来的问题是搞清楚，运行时他执行的是哪个fun函数？


<!-- ----------------------------------------------------------------------------- -->


</body>
</html>
