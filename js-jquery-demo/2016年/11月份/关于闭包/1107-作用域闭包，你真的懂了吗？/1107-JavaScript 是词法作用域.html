<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

  我们需要知道 JavaScript 里面的函数会创建内部词法作用域，是的，JavaScript 是词法作用域，

  也就是说作用域与作用域的层级关系在你书写的时候就已经确定了，而不是调用的时候，调用的时候确定的称为动态作用域，

  由于不是本篇文章的重点，就不再详细解释了，举两个例子自己领悟：

<!-- ---------------------------------------------------------------------------------- -->
<script>
    var name = 'fruit'

    function apple() {
        console.log(this) //this  指向的是window
        console.log(name)
    }

    function orange() {
        var name = 'orange'
        apple()
    }
    orange() // fruit

// 这个打印出来的结果是fruit来的
</script>

由于 JavaScript 是词法作用域，所以 apple 函数的局部作用域的上层作用域是全局作用域，

从书写的位置就看出来了。假设 JavaScript 是动态作用域，就要看函数的调用顺序了，由于 apple 是在 orange 中调用的，

所以 apple 的上层作用域是 orange 的局部作用域，那样的话会输出 orange！

这样的话，就制定了一套作用域访问的规则，这也是会有闭包的原因之一！

<!-- ------------------------------------------------------------------------------------ -->

词法作用域意味着作用域是由书写代码时函数声明的位置决定的。

Javascript中有两个机制可以“欺骗”词法作用域：eval()和with。

前者可以对一段包含一个或多个声明的代码字符串进行演算，并借此来修改已经存在的词法作用域（在运行时）。

后者本质上是通过将一个对象的引用当作作用域来处理，将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域（同样是在运行时）。

这两个机制的副作用是引擎无法在编译时对作用域查找进行优化，因为引擎谨慎的认为这样的优化是无效的。使用这其中的任何一个机制都将导致代码运行缓慢。不要使用它们。

<!-- -------------------------------------------------------------------------------------- -->


</body>
</html>
