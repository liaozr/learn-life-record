<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

函数就是一段可以反复调用的代码块。

函数使用function关键字来定义，还包括一个称为形参（parameter）的标识符列表，这些参数在函数体内像局部变量一样工作。

如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。

<!-- -------------------------------------------------------------------------------- -->

（3）Function()
函数定义还可以通过Function()构造函数来定义

<script>
    var f = new Function('x', 'y', 'return x+y');

    // 等价于
    var f = function(x, y) {
        return x + y;
    }
</script>

除了最后一个参数是函数体外，前面的其他参数都是函数的形参。如果函数不包含任何参数，只须给构造函数简单的传入一个字符串---函数体---即可。 不过，Function()构造函数在实际编程中很少会用到。

<!-- -------------------------------------------------------------------------------- -->

函数可以调用自身，这就是递归（recursion）

<script>
    function f(x) {
        if (x > 2) {
            console.log(x);
            return f(x - 1);
        } else {
            return 1;
        }
    }
    f(4);
    // 4
    //3
</script>

<!-- -------------------------------------------------------------------------------- -->

注意：以表达式定义的函数并没有“被提前”。

<script>

    f();
    var f = function() {};
    // TypeError: f is not a function


    // 变量其实是分为声明， 赋值两部分的， 上面的代码等同于下面的形式
    var f;
    f();
    f = function() {};

</script>

调用f的时候，f只是被声明了，还没有被赋值，等于undefined，所以会报错。

<!-- -------------------------------------------------------------------------------- -->

可变长的实参列表：实参对象

当调用函数时，传入的实参个数超过函数定义时的形参个数时，是没有办法直接获得未命名值的引用。

这时，标识符arguments出现了，其指向实参对象的引用，实参对象是一个类数组对象，可以通过数字下标来访问传入函数的实参值，而不用非要通过名字来得到实参。
-------------------------------------------------------------------------------

<script>
    function go(x) {
        console.log(arguments[0]);
        console.log(arguments[1]);
    }
    go(1, 2);
    //1
    //2
</script>
-------------------------------------------------------------------------------

arguments有一个length属性，用以标识其所包含元素的个数。

<script>
    function f(x) {
        console.log(arguments.length);

    }
    f(1, 2) // 2
</script>
-------------------------------------------------------------------------------

注意：arguments并不是真正的数组，它是一个实参对象。

每个实参对象都包含以数字为索引的一组元素以及length属性。

通过实参名字来修改实参值的话，通过arguments[]数组也可以获取到更改后的值。

<script>
    function f(x) {
        console.log(x); // 1
        arguments[0] = null;
        console.log(x); // null
    }
    f(1);
</script>

-------------------------------------------------------------------------------

在上面的例子中，arguments[0]和x指代同一个值，修改其中一个的值会影响到另一个。

注意：如果有同名的参数，则取最后出现的那个值。

<script>
    function f(x, x) {
        console.log(x);
    }
    f(1, 2) // 2
</script>

<!-- -------------------------------------------------------------------------------- -->

7、将对象属性用做实参

当一个函数包含超过三个形参时，要记住调用函数中实参的正确顺序是件让人头疼的事。不过，我们可以通过名/值对的形式传入参数，这样就无法管参数的顺序了。

<script>
    function f(params) {
        console.log(params.name);
    }
    f({
        name: 'a'
    })
</script>

<!-- -------------------------------------------------------------------------------- -->

2、闭包
JavaScript的函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量，这就是JavaScript的闭包。 闭包的最大用处有两个，一个是可以读取函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。

<script>
    function f(a) {
        return function() {

            return a++;
            // a++ 的区别

        };
    }

    var c = f(1);
    console.log(c());   //1
    console.log(c());   //2
    console.log(c());   //3
</script>

<!-- -------------------------------------------------------------------------------- -->

13、立即调用的函数表达式（IIFE）

在Javascript中，一对圆括号()是一种运算符，跟在函数名之后，表示调用该函数。

<script>
    (function() {
        // statement
    }())
</script>

上面的函数会立即调用。

注意：上面代码的圆括号的用法，function之前的左圆括号是必需的，因为如果不写这个左圆括号，JavaScript解释器会试图将关键字function解析为函数声明语句。而使用圆括号，JavaScript解释器才会正确地将其解析为函数定义表达式。

当然，下面的方法也会以表达式来处理函数定义的方法。

<script>
    !function(){}();

    ~function(){}();

    -function(){}();

    +function(){}();
 </script>

 <!-- -------------------------------------------------------------------------------- -->

 14、eval命令

 eval命令的作用是，将字符串当作语句执行。

<script>

    eval('var a=1');

    a //1

</script>

 eval没有自己的作用域，都在当前作用域内执行

-----------------------------------------------------------------------------------

 JavaScript规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域。

<script>
    (function() {
        'use strict';
        eval('var a=1');
        console.log(a); //ReferenceError: a is not defined
    })();
</script>

<!-- -------------------------------------------------------------------------------- -->




</body>
</html>
