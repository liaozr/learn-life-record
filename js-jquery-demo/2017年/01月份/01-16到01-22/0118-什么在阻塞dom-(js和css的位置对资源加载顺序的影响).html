<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

<!-- --------------------------------------------------------------------------- -->

  什么是DOM？

  DOM是Document Object Model（文档对象模型）的缩写

  <!-- --------------------------------------------------------------------------- -->

  用人话描述DOM

  简单的讲，当你使用一个类似Chrome开发者工具的东东时，你可以看到一个可视化的DOM。

  你的HTML并不是DOM，但Chrome开发者工具为你展现了一个经过HTML或JavaScript加工之后的DOM。

  所以你可以把DOM理解成解析后的HTML。

<!-- --------------------------------------------------------------------------- -->

什么在阻塞DOM？

当我们分析页面速度时，我们总要考虑什么阻塞了DOM导致我们的页面加载出现延迟。这些阻塞因素我们可以叫做 阻塞渲染的资源 ，例如 HTML、CSS（也包括web font）和 JavaScript。

要查看什么阻塞了DOM的最简单的方法之一就是使用 Chrome开发者工具 (Chrome DevTools) 和Google的 PageSpeed Insight。在下面的例子中，我们使用了最新的Chrome开发者工具 （可以通过 Chrome Canary 获得）。

在Chrome中启动开发者工具

切换到 Network (网络)面板，刷新页面（ Win: Ctrl + R, Mac: Cmd + R）

现在你会看到一个加载时间瀑布图。这里有两个值得我们关注的东东：第一个是 DOMContentLoaded 是384ms（译者注：原文如此，看图的话应该是281ms），第二个就是瀑布图中的在蓝线之前的绿色部分（译者注：原图有点问题，蓝线看起来是紫色的）

我们知道CSS和JavaScript都是阻塞渲染的资源，它们都会在蓝色的DOMContent之前加载。

请注意，图像是不会阻塞渲染的 ，所以如果有图像落在蓝线之前或之上你可以放心的忽略掉，当然优化图像也是很重要的一项工作。

在这个例子里面，我们可以看到 style.css 和 jquery.min.js 都是阻塞渲染的资源。

<!-- ---------------------------------------------------------------------------- -->

通过优化关键渲染路径来避免CSS和JavaScript阻塞DOM

<!-- ---------------------------------------------------------------------------- -->

如果你追求一个完全没有阻塞的CSS，那么你的唯一选项就是：在HTML中内联嵌入你的CSS。 (css inline（内联）)

你可以把需要初始渲染的CSS，一般来讲就是第一屏的样式，

直接放在 HEAD 里面的 <style></style> 中，然后剩下的CSS放在 </body> 之前。

这样做可以完全避免CSS阻塞渲染。

<!-- ---------------------------------------------------------------------------- -->

减少css阻塞 dom的一些建议：

减少CSS的数量（尽可能放到一个CSS文件中）

Minify CSS文件（删除多余的空格、字符、注释等）

尽可能的减少样式数量（译者注：和第三条不同，是减少样式数量，不是文件数量）

一些用于最小化（Minify）CSS的工具

<!-- ---------------------------------------------------------------------------- -->

JavaScript

非渲染阻塞的JavaScript

有一些关于JavaScript的最佳实践需要牢记在心：

把脚本放在页面尾部 </body> 之前的位置

使用async或defer指令来避免阻塞渲染

减少JavaScript的数量（尽量整合成一个JS文件）

Minify（最小化）JavaScript

如果JavaScript很小的话，可以内联嵌入

<!-- ---------------------------------------------------------------------------- -->

用一句话概括就是： JS 全阻塞，CSS 半阻塞。(词是我发明的，方便记忆而已)

JS 会阻塞后续 DOM 解析以及其它资源(如 CSS，JS 或图片资源)的加载。

CSS 不会阻塞后续 DOM 结构的解析，不会阻塞其它资源(如图片)的加载，但是会阻塞 JS 文件的加载。

现代浏览器很聪明，会进行 prefetch 优化，

浏览器在获得 html 文档之后会对页面上引用的资源进行提前下载。(注意仅仅只是提前下载

<!-- ---------------------------------------------------------------------------- -->

js 会阻塞后续 DOM 解析以及其它资源(如 CSS，JS 或图片资源)的加载。

这个很好理解：

JS 运行在浏览器中，是单线程的，每个 window 一个 JS 线程，所以当然会阻塞后续 DOM 树的解析咯。
JS 有可能会修改 DOM 结构，给 DOM 添加样式等等，所以这就意味着在当前 JS 加载执行完成前，后续资源的加载可能是没有意义的。

其次第二点：

CSS 不会阻塞后续 DOM 结构的解析，不会阻塞其它资源(如图片)的加载，但是会阻塞 JS 文件的加载。

这个也好理解：JS 代码在执行前，浏览器必须保证在 JS 之前的所有 CSS 样式都解析完成，不然不就乱套了，前面的 CSS 样式可能会覆盖 JS 文件中定义的元素样式，这是 CSS 阻塞后续 JS 执行的根本原因。

<!-- ---------------------------------------------------------------------------- -->

所以知道了上述的结论之后，我们在开发的时候应该尽可能地:

将样式或 CSS 文件定义在 head 中，并且在处理此类请求的时候应该尽快能够响应(CDN 什么的)，如果像上面请求一个 CSS 文件都要 10s 的话，那你这页面估计没多少人有耐心等下去。

将 JS 脚本文件放在 body 底部，让 DOM 结构能优先渲染出来，避免 DOM 被阻塞。

当编写比较耗时的 JS 代码时候尽可能使用异步的方式进行加载，比如 setTimeout, ajax 等等，同样也是为了避免页面渲染耗时过长，影响用户体验。

<!-- ---------------------------------------------------------------------------- -->

上面介绍了 JS 会阻塞后续 DOM 解析以及其它资源(如 CSS，JS 或图片资源)的加载，这是在没有考虑到 defer, async 的情况下。

当浏览器碰到 script 脚本的时候：(不考虑浏览器的 prefetch)

没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，当然还得等待前面的 CSS 文件渲染完。
<script async src="script.js"></script>

有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行(下载异步，执行同步)。
<script defer src="script.js"></script>

有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。

从使用的角度来看，首先把脚本丢到 body 底部是比较好的优化选择，此法可保证非脚本的其他一切元素能够以最快的速度得到加载和解析。

<!-- ---------------------------------------------------------------------------- -->

总结：

由于现代浏览器都存在 prefetch，所以 defer, async 可能并没有太多的用途，可以作为了解扩展知识，仅仅将脚本文件放到 body 底部就可以起到很不错的优化效果。
defer 和 async 都是异步加载脚本文件。

慎用 async，因为它完全不考虑依赖关系，只要下载完后就加载，不考虑此时页面样式先后的加载顺序，不过它对于那些可以不依赖任何脚本或不被任何脚本依赖的脚本来说却是非常合适的，最典型的例子：Google Analytics。
耗时较长的脚本代码可以使用 defer 来推迟执行。

<!-- ---------------------------------------------------------------------------- -->



</body>

</html>
