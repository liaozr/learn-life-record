<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

<!-- ----------------------------------------------------------------------------------------------- -->

  7.创建对象的三种方法

  第一种方式，字面量
  var o1 = {name:"o1"}
  var o2 = new Object({name: "o2"})

  第二种方式，通过构造函数
  var M = function(name){ this.name = name }
  var o3 = new M("o3")

  第三种方式，Object.create
  var p = {name:"p"}
  var o4 = Object.create(p)

<!-- ----------------------------------------------------------------------------------------------- -->

  9.当new Foo()时发生了什么

  1.创建了一个新对象

  2.将this指向这个新对象

  3.执行构造函数里面的代码

  4.返回新对象（this）

<!-- ----------------------------------------------------------------------------------------------- -->

11.浏览器渲染原理

HTML被解析成DOM Tree，CSS被解析成CSS Rule Tree

把DOM Tree和CSS Rule Tree经过整合生成Render Tree（布局阶段）

元素按照算出来的规则，把元素放到它该出现的位置，通过显卡画到屏幕上

<!-- ----------------------------------------------------------------------------------------------- -->

12.前端路由的原理

前端的路由和后端的路由在实现技术上不一样，但是原理都是一样的。

在 HTML5 的 history API 出现之前，前端的路由都是通过 hash 来实现的，hash 能兼容低版本的浏览器。

两种实现前端路由的方式

HTML5 History两个新增的API：
history.pushState 和 history.replaceState，两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。

Hash就是url 中看到 # ,我们需要一个根据监听哈希变化触发的事件( hashchange) 事件。

我们用 window.location 处理哈希的改变时不会重新渲染页面，而是当作新页面加到历史记录中，这样我们跳转页面就可以在 hashchange 事件中注册 ajax 从而改变页面内容。

优点
从性能和用户体验的层面来比较的话，后端路由每次访问一个新页面的时候都要向服务器发送请求，然后服务器再响应请求，
这个过程肯定会有延迟。而前端路由在访问一个新页面的时候仅仅是变换了一下路径而已，
没有了网络延迟，对于用户体验来说会有相当大的提升。

缺点
使用浏览器的前进，后退键的时候会重新发送请求，没有合理地利用缓存。

<!-- ----------------------------------------------------------------------------------------------- -->



</body>

</html>
