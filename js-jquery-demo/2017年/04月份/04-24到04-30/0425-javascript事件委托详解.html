<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

  <!-- -------------------------------------------------------------------------------- -->

  事件委托，通俗地来讲，就是把一个元素响应事件（click、focus......）的函数委托到另一个元素；

  一般来讲，会把一个或者一组元素的事件委托到它的父层或者更外层元素上，真正绑定事件的是外层元素，当事件响应到需要绑定的元素上时，

  会通过事件冒泡机制从而触发它的外层元素的绑定事件上，然后在外层元素上去执行函数；


  DOM 中事件委托的实现是利用事件冒泡的机制


  事件模型是指分为三个阶段：

  捕获阶段：在事件冒泡的模型中，捕获阶段不会响应任何事件；

  目标阶段：目标阶段就是指事件响应到触发事件的最底层元素上；

  冒泡阶段：冒泡阶段就是事件的触发响应会从最底层目标一层层地向外到最外层（根节点），事件代理即是利用事件冒泡的机制把里层所需要响应的事件绑定到外层；

<!-- -------------------------------------------------------------------------------- -->

事件委托的优点

1. 减少内存消耗

试想一下，若果我们有一个列表，列表之中有大量的列表项，我们需要在点击列表项的时候响应一个事件；

<ul id="list">
  <li>item 1</li>
  <li>item 2</li>
  <li>item 3</li>
  ......
  <li>item n</li>
</ul>
// ...... 代表中间还有未知数个 li

如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能；

因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件的时候再去匹配判断目标元素；

所以事件委托可以减少大量的内存消耗，节约效率。

2. 动态绑定事件

比如上述的例子中列表项就几个，我们给每个列表项都绑定了事件；

在很多时候，我们需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；

如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的；

所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。

<!-- --------------------------------------------------------------------------------------- -->

$.on: 基本用法:

<script>
    // $('.parent').on('click', 'a', function() {
    //     console.log('click event on tag a');
    // })，
</script>

它是 '.parent' 元素之下的 a 元素的事件代理到 $('.parent') 之上，只要在这个元素上有点击事件，就会自动寻找到 .parent 元素下的 a 元素，然后响应事件；

<!-- -------------------------------------------------------------------------------------- -->

<ul id="list2">
    <li>item 1</li>
    <li>item 2</li>
    <li>item 3</li>
    <li>item n</li>
</ul>
<script>
    // ...... 代表中间还有未知数个 li
    // 我们来实现把# list 下的 li 元素的事件代理委托到它的父层元素也就是# list 上：

    // 给父层元素绑定事件
    document.getElementById('list2').addEventListener('click', function(e) {
        // 兼容性处理
        var event = e || window.event;
        var target = event.target || event.srcElement;
        // 判断是否匹配目标元素
        if (target.nodeName === 'LI') {
            console.log('the content is: ', target.innerHTML);
        }
    });
</script>

在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，

然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；

<!-- -------------------------------------------------------------------------------------- -->

</body>

</html>
