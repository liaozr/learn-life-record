<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

<!-- ---------------------------------------------------------------------------------- -->

2、++i 和 i++的区别

//实例说明
var i = 5;
5 + i++ //->10

//i++ 是先运算i本身再加1

//========
var j = 5;
5 + (++j) //->11

//++j 是本身先加1再运算

//面试题
var n = 2;
var num =  5 + (++n) + (n++) + (n++) + (++n); //  - > 21

<!-- ---------------------------------------------------------------------------------- -->

4、区分this

函数执行，首先看函数名是否有".",有的话，"."前面是谁this就是谁；没有的话this就是window

自执行函数的this永远是window

给元素的某一个事件绑定方法，当事件触发的时候，执行对应的方法，方法中的this是当前的元素

构造函数中的this是这个类的实例

this还可以通过call、apply、bind来改变

<!-- ---------------------------------------------------------------------------------- -->

5、单例模式

描述同一个事物（同一个对象）的属性和方法放在一个内存空间下，起到分组的作用，这样不同事物之间的属性名相同，相互也不会发生冲突，

我们把这种分组编写代码的模式叫做“单例模式”；

<script>

    var obj = {
        name: '张三',
        age: '18',
        writeJs: function() {
            console.log('my is ' + this.name + ' can write js');
        }

    }

    obj.writeJs();
</script>

注：obj又叫做“命名空间”，单例模式项目开发经常使用，我们可以使用单例模式进行模块化开发；

<!-- ---------------------------------------------------------------------------------- -->

6、工厂模式

单例模式虽然能解决分组作用，但是不能实现批量生产，属于手工作业模式；

工厂模式->“函数的封装”，“低耦合高内聚”：减少页面中的冗余代码，提高代码的重复利用

<script>
    function createJs(name, age) {
        var obj = {};
        obj.name = name;
        obj.age = age;
        obj.writeJs = function() {
            console.log('my is ' + this.name + ' can write js');
        }
        return obj;
    }

    var zhangsan = createJs('张三2', '18');

    zhangsan.writeJs();
</script>

<!-- ---------------------------------------------------------------------------------- -->

通过对象名.属性名获取属性值的时候，首先在对象的私有属性找，如果私有属性存在，则获取的是私有属性值；

如果私有没有，则通过__proto__找到所属类的原型，原型上存在的话获取的是公有的属性值；

如果原型上也没有，则继续通过原型上的__proto__继续向上查找，一直找到Object.protoype为止

<!-- ---------------------------------------------------------------------------------- -->

对于 apply、call 二者而言，作用完全一样，只是接受参数的方式不太一样。

func.call(this, arg1, arg2);

func.apply(this, [arg1, arg2])

<!-- ---------------------------------------------------------------------------------- -->

13、DOM回流（重排 reflow）、DOM重绘、DOM映射

DOM回流：DOM树渲染完毕以后，只要页面中的HTML结构发生变化（增加删除元素、位置发生变化），
浏览器都要重新计算一遍最新的DOM结构，重新对当前页面进行渲染；

DOM重绘：DOM树位置不发生变化，如元素的颜色背景发生变化，会只针对这个元素渲染，不渲染整个页面

DOM映射：页面中的标签和Js中获取到的元素对象（元素集合）是紧紧绑定在一起的，页面中HTML结构改变了，
Js不需要重新获取，集合里面的内容也会跟着自动改变

<!-- ---------------------------------------------------------------------------------- -->

3、文档碎片方式

<script>

    var oUl = document.getElementById('ul');
    var frg = document.createDocumentFragment(); //创建一个文档碎片
    var oLi = document.createElement('li');
    oLi.innerHTML = "hello world";
    frg.appendChild(oLi);

    oUl.appendChild(frg);

    frg = null; //手动清空碎片
</script>

<!-- ---------------------------------------------------------------------------------- -->

正则的创建

1. 字面量创建
var reg = /\d/;

2. 实例创建
var reg = new RegExp("\d");
----------------------------------------------------------------------------------

元字符
每一个正则表达式都是由元字符和 修饰符组成
具有特殊意义的元字符

\ :转义后面字符所代表的含义

^ :以某一个元字符开始

$ :以某一个元字符结束

\n :匹配一个换行符

. :除了\n以外的任意字符

----------------------------------------------------------------------------------

() :分组

x|y :x或y中的一个

[xyz] :x或者y或者z中的任何一个字符

[a-z] :a-z之间的任意字符

[^a-z]:除了a-z之间的任何字符

\d :一个0-9之间的任何数字

\b :匹配一个边界符

\w :数字字母下划线中的任意一个字符

\s:匹配一个空白字符 空格、制表符、换页符...

----------------------------------------------------------------------------------

代表出现次数的量词元字符
\* ：出现0到多次

\+ ：出现1到多次

? :出现0到1次

{n} :出现n次

{n,} :出现n到多次

{n,m} :出现n到m次

<!-- ---------------------------------------------------------------------------------- -->


正则的修饰符(g、i、m)

<script>

    //g:全局匹配
    //i:忽略大小写匹配
    //m:多行匹配

    var reg = /\d+/g
    var arr = []
    res = reg.exec('ducen23niubi12');
    while (res) {
        arr.push(res[0]);
        res = reg.exec('ducen23niubi12')
    }
    arr //["23", "12"]
</script>

<!-- ---------------------------------------------------------------------------------- -->

字符串中的match方法

把所有和正则匹配的字符都获取到

<script>

    var reg = /\d+/g

    var arr = 'ducen23niubi12'.match(reg);

    arr //["23", "12"]

</script>

<!-- ---------------------------------------------------------------------------------- -->

字符串中的replace方法

replace中的匿名函数执行次数，取决于正则捕获的次数

每一次执行匿名函数里面传递的参数值arguments和我们自己通过exec捕获到的结果是非常类似的（即使正则有分组，我们也可以通过arguments获取）

return：你返回的结果是啥，就相当于把当前大正则捕获的内容替换成返回的内容

<script>
    var str = '2343289';
    str = str.split('').reverse().join('');
    str = str.replace(/(\d{3})/g, '$1,');
    str.split('').reverse().join('');

    // <!--结果：2,343,289-->
    })
</script>

<!-- ---------------------------------------------------------------------------------- -->

</body>

</html>
