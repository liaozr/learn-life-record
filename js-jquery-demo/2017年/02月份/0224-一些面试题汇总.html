<!doctype html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
	<script src='jquery.js'></script>
</head>
<body>

overflow 可能的值:

值	描述

visible	默认值。内容不会被修剪，会呈现在元素框之外。
hidden	内容会被修剪，并且其余内容是不可见的。
scroll	内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。
auto	如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。
inherit	规定应该从父元素继承 overflow 属性的值。

如果值为 scroll，不论是否需要，用户代理都会提供一种滚动机制。因此，有可能即使元素框中可以放下所有内容也会出现滚动条。

<!-- ---------------------------------------------------------------------- -->

alt 用于图片没显示时在图片显示区域显示一个说明文字。

title 表示鼠标在图片上停留时，显示一个悬浮框，其中显示的文字。

<!-- ---------------------------------------------------------------------- -->

js的事件的三个阶段,事件委托的原理

DOM2级事件规定的事件流的三个阶段：捕获，目标，冒泡（IE8以及更早版本不支持DOM事件流）;

一、为了给动态生成的元素增加事件时用委托 二、如果是一次性要给很多个相同的元素绑定事件时用委托 好处：增强性能和代码可读性


   <ul id='ul'>
   	<li data-id='111'>
   		1111
   	</li>
   	<li>
   		222
   	</li>
   	<li>
   		333
   	</li>
   </ul>
   <script>
     $(function(){
     	var ul=$("#ul")
     	ul.on('click','li',function(){
     		console.log($(this).text());
     	})
     })
   </script>

<!-- ---------------------------------------------------------------------- -->

 HTML5触摸事件(touchstart、touchmove和touchend)

 touchstart事件：当手指触摸屏幕时候触发，即使已经有一个手指放在屏幕上也会触发。

 touchmove事件：当手指在屏幕上滑动的时候连续地触发。在这个事件发生期间，调用preventDefault()事件可以阻止滚动。

 touchend事件：当手指从屏幕上离开的时候触发。

 <!-- ---------------------------------------------------------------------- -->
 
 Array 的原型方法。

 <script>
   var arr=[1,2,3,4,1,2,5]
   Array.prototype.reduce=function(arr){
   	 // console.log(Array.from(new Set(arr)))
   	 return Array.from(new Set(arr))
   }
   console.log( arr.reduce(arr) );
 </script>

 <!-- ---------------------------------------------------------------------- -->

  如何提升for循环的性能。

  优化循环的第一步就是减少对象成员及数组项的查找次数。前面例子中每次循环都要查找items.length，这样做很耗时，由于该值在循环运行过程中从未变过，因此产生了不必要的性能损失，提高整个循环的性能很简单，只查找一次属性，并把值存储到一个局部变量中，然后在控制条件中使用整个变量 

  javascript代码 

  <script>

	for(var i = 0,len = item.length; i < len; i++){  
	    process(items[i]);  
	}  

  </script>

 <!-- ---------------------------------------------------------------------- -->

  this就是指向当前事件所绑定的元素，而e.target指向事件执行时鼠标所点击区域的那个元素。

  容易搞不懂的地方是，初学者会认为当前事件所绑定的元素不就是鼠标所点击的那个元素嘛，这时候就要看看时间绑定的元素内部有没有子元素了，如果有子元素的话e.target指向这个子元素，如果没有，e.target和this都指向事件所绑定的元素。


  每次触发DOM事件时会产生一个事件对象（也称event对象），此处的参数e接收事件对象。而事件对象也有很多属性和方法，其中target属性是获取触发事件对象的目标，也就是绑定事件的元素，e.target表示该DOM元素，然后在获取其相应的属性值。

  例如：

  <script>

	$('.target1').change(function(e) {
	        $("#result").html(e.target.value)
	});
	
  </script>

  e.target就等价于$('target1')

  故e.target.value就等价于$('target1').val()

  <!-- ---------------------------------------------------------------------- -->


</body>
</html>