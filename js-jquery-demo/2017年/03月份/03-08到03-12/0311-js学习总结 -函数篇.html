<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>

函数的定义和调用：

如果没有return语句，函数执行完毕后也会返回结果，只是结果为undefined。

JavaScript允许传入任意参数，即使函数内部不需要这些参数，也不影响调用。

JavaScript还有一个免费赠送的关键字arguments，它只在函数内部起作用，并且永远指向当前函数的调用者传入的所有参数。

arguments类似Array但它不是一个Array
利用arguments即使函数不定义任何参数，还是可以拿到参数的值。

<script>

	function abs() {
		 if (arguments.length === 0) {
		     return 0;
		 }
		 var x = arguments[0];
		 return x >= 0 ? x : -x;
	}

	abs(); // 0
	abs(10); // 10
	abs(-9); // 9

</script>

<!-- ------------------------------------------------------------------------------ -->

return语句必须在一行上，如果必须为多行返回，需要在retrun后紧跟 {，正确的多行写法如下：

<script>

	function foo() {
	 return { // 这里不会自动加分号，因为{表示语句尚未结束
	     name: 'foo'
	 };
	}

</script>

<!-- ------------------------------------------------------------------------------ -->

为了防止造成命名冲突，比较好的方法是把自己的所有变量和函数，都绑定到一个全局变量中：

<script>

	// 唯一的全局变量MYAPP:
	var MYAPP = {};

	// 其他变量:
	MYAPP.name = 'myapp';
	MYAPP.version = 1.0;

	// 其他函数:
	MYAPP.foo = function () {
	 return 'foo';
	};
    
</script>

<!-- ------------------------------------------------------------------------------ -->

在for循环是无法定义具有局部作用域的的变量的。在ES6中可以使用let替代var可以申明一个块级作用域的变量。

<!-- ------------------------------------------------------------------------------ -->

对于常量的定义，以前都是使用全部大写来规定，现在ES6总可以使用关键字const来定义常量，const与let都具有块级作用域，并且const定义以后无法修改。

<!-- ------------------------------------------------------------------------------ -->

补充说明一下let和const的特点，不存在变量提升、会造成暂时性死区、不允许重复定义。

<!-- ------------------------------------------------------------------------------ -->

this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，实际上this的最终指向的是那个调用它的对象。

在《javascript语言精髓》中大概概括了4种调用方式：

1. 方法调用模式
2. 函数调用模式
3. 构造器调用模式
4. apply/call调用模式

特别补充：

在构造器调用时，如果加入了return并且return了一个对象，this会指向这个return的对象。
严格模式下在函数内部定义的函数，this指向undefined（在非strict模式下，它指向全局对象window）
那么有没有办法去控制this的指向了？
有的，可以使用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。另一个与apply()类似的方法是call()，唯一区别是：

apply()把参数打包成Array再传入；
call()把参数按顺序传入。
另外ES5还加入了一个bing()方法，它会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。
利用apply()，我们还可以动态改变函数的行为。
JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。

<!-- ------------------------------------------------------------------------------ -->

高阶函数：

一个函数接收另一个函数作为参数，这种函数就称之为高阶函数。

forEach方法，是最基本的方法，就是遍历与循环，默认有3个传参：分别是遍历的数组内容item、数组索引index、和当前遍历数组Array。另外，除去第一个必须的回调函数参数，还可以接受一个上下文参数(改变回调函数的this指向)；并且forEach不会遍历空元素。

map方法，基本用法与forEach一致，但是不同的，它会返回一个新的数组，所以在callback需要有return值，如果没有，会返回undefined。(从字面理解，map就是映射的意思)

filter方法，用法和map很相似，从字面理解，就是过滤、筛选的意思。但是函数的callback需要返回布尔值true或false，并且返回值只需要为弱等==即可。

some 方法，对数组中每一项运行指定函数，如果该函数对任一项返回true，则返回true。(一旦遇到true，就会中断循环，返回true，类似于||判断)

every方法，对数组中的每一项运行给定函数，如果该函数对每一项返回true，则返回true。(一旦遇到false，就会中断循环，返回false，类似于&&判断)

sort方法，默认把所有元素先转换为String再进行ASCII码排序，所以这个很坑爹。要想正确的排序，需要添加一个函数。sort方法，可以接受一个回调函数，默认有两个传参：分别是比较的数组项。

<!-- ------------------------------------------------------------------------------ -->


</body>
</html>