<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

<!-- ------------------------------------------------------------------------------------ -->

_proto_属性:

同一个函数造出来的实例对象能共享这个函数的prototype下的方法和属性，

每个实例化对象都有_proto_属性，它是一个指针，指向函数的prototype，也就是保存了它的地址。

（JS中任何对象的值都是保存在堆内存中，我们声明的变量只是一个指针，保存了这个对象的实际地址，所以有了地址就能找到对象），

所以总得来说，每个实例化对象都有_proto_属性，保存了构造函数的原型对象的地址，

通过这个属性就可以拥有原型对象下的所有属性和方法，_proto_属性实际就是实例化对象和原型对象之间的连接

<!-- ------------------------------------------------------------------------------------ -->

原型链：

每个函数都可以成为构造函数，每个函数都有原型对象，每个原型对象也可以是一个实例化对象，

比如，你创建了一个函数fun,它是构造函数function的实例化对象，而function的原型对象，又是Object的实例对象。

所以fun有个_proto_属性可以访问到function的原型对象,function原型对象也是个实例对象，也有个_proto_属性,可以访问到Object的原型对象，所以通过_proto_属性，就形成了一条原型链。

每个实例化对象都可以访问到链子上方的方法和属性，所以fun是可以访问Object原型对象下的方法和属性的。

实际上所有对象都可以访问到Object的原型对象。

<!-- ------------------------------------------------------------------------------------ -->

原型链的访问规则：先在自身的下面寻找，再去一级一级的往原型链上找。

<!-- ------------------------------------------------------------------------------------ -->

原型对象：

原型对象下可能有三种属性：

1 原型对象所带方法和属性 2 constructor 3_proto_属性

constructor:构造函数属性，每个函数的原型对象都有的默认属性，指向函数。

每个实例化对象本身是没有constructor属性的，他们下面默认只有一个_proto_属性,用来连接原型对象，而和构造函数本身是没有直接的联系的。

所以它的constructor是访问的原型对象上的。

所以当原型对象的constructor变化了，实例化对象的constructor也会改变。

但是如果这个对象本身既是原型对象，又是实例化对象，那就拥有了constructor属性，无需从原型对象上面访问。**

<!-- ------------------------------------------------------------------------------------ -->



</body>
</html>
