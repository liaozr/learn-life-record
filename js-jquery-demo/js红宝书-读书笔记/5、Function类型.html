<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

<!-- ------------------------------------------------------------------------------- -->

函数声明与函数表达式

解析器会率先读取函数声明，并使其在执行任何代码之前可用；

至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行。

<!-- ------------------------------------------------------------------------------- -->

函数内部属性

arguments
this

arguments具有一个callee属性，该属性是一个指针，指向拥有这个arguments对象的函数。

<script>

    function factorial(num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * factorial(num - 1)
        }
    }

    // 等价于
    function factorial(num) {
        if (num <= 1) {
            return 1;
        } else {
            return num * arguments.callee(num - 1)
        }
    }

</script>

<!-- ----------------------------------------------------------------------------------- -->

函数属性和方法

每个函数都包含两个属性:

length: 表示函数希望接收的命名参数的个数
prototype: 保存实例方法

<!-- ----------------------------------------------------------------------------------- -->

每个函数都包含两个非继承而来的方法：

apply()

call()

这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this 对象的值。

首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。

其中，第二个参数可以是Array的实例，也可以是arguments对象。

call()方法与apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。

对于call()方法而言，第一个参数是this 值没有变化，变化的是其余参数都直接传递给函数。

换句话说，在使用call()方法时，传递给函数的参数必须逐个列举出来。

注：在严格模式下，未指定环境对象而调用函数，则this 值不会转型为window。除非明确把函数添加到某个对象或者调用apply()或call()，否则this 值将是undefined。

在非严格模式下，call、apply的第一个参数传递为null或undefined时，函数体内的this会指向默认的宿主对象，在浏览器中则是window。

ECMAScript 5定义了一个方法bind()，这个方法会创建一个函数的实例，其this值会被绑定到传给bind()函数的值。

<!-- ----------------------------------------------------------------------------------- -->

</body>

</html>
