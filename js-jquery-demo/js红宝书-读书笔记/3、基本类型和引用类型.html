<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

  <!-- ------------------------------------------------------------------------------- -->

  基本类型和引用类型

  复制变量值

  复制基本类型值，这两个变量相互独立，互不影响。

  复制引用类型（对象），值引用是一个指针，改变其中一个对象，会影响另一个对象。

<!-- ------------------------------------------------------------------------------- -->

传递参数

<script>

    function setName(obj) {
        obj.name = "Nicholas";
    }
    var person = new Object();
    setName(person);
    alert(person.name); //"Nicholas"

</script>

<!-- ------------------------------------------------------------------------------- -->

以上代码中创建一个对象，并将其保存在了变量person 中。然后，这个变量被传递到setName()函数中之后就被复制给了obj。

在这个函数部，obj 和person 引用的是同一个对象。

换句话说，即使这个变量是按值传递的，obj 也会按引用来访问同一个对象。

于是，当在函数内部为obj 添加name属性后，函数外部的person 也将有所反映；因为person 指向的对象在堆内存中只有一个，而且是全局对象。

有很多开发人员错误地认为：在局部作用域中修改的对象会在全局作用域中反映出来，就说明参数是按引用传递的。为了证明对象是按引用传递的，我们再看
一看下面这个经过修改的例子：

<script>

    function setName(obj) {
        obj.name = "Nicholas";
        obj = new Object();
        obj.name = "Greg";
    }
    var person = new Object();
    setName(person);
    alert(person.name); //"Nicholas"

</script>

这个例子与前一个例子的唯一区别，就是在setName()函数中添加了两行代码：一行代码为obj重新定义了一个对象，另一行代码为该对象定义了一个带有不同值的name属性。

在把person传递给setName()后，其name 属性被设置为"Nicholas"。然后，又将一个新对象赋给变量obj，同时将其name属性设置为"Greg"。

如果person 是按引用传递的，那么person 就会自动被修改为指向其name属性值为"Greg"的新对象。

但是，当接下来再访问person.name 时，显示的值仍然是"Nicholas"。

这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。

实际上，当在函数内部重写obj时，这个变量引用的就是一个局部对象了。

而这个局部对象会在函数执行完毕后立即被销毁。

<!-- ------------------------------------------------------------------------------- -->

检测类型

虽然在检测基本数据类型时typeof 是非常得力的助手，但在检测引用类型的值时，这个操作符的用处不大。

通常，我们并不是想知道某个值是对象，而是想知道它是什么类型的对象。

为此，ECMAScript提供了instanceof 操作符。

<!-- ------------------------------------------------------------------------------- -->

小结

基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；
从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；

引用类型的值是对象，保存在堆内存中；

包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；

<!-- ------------------------------------------------------------------------------- -->




</body>

</html>
